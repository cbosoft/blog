---
title: "One side of a conversation about Rust-lang."
layout: post
excerpt: "What? No parentheses around conditions?!"
tags: software-dev
---

# Rust-lang

"Huh? [Rust](https://www.rust-lang.org) is a statically and strongly typed systems programming language? So what? I have `c` and `c++` for that kind of thing. They offer extreme portability (`c` especially). Why would I want anything else?"

"Oh right, memory safety. I see. That's a compelling argument. Or, it would be. Its 2022! We have great features built into our wonderful `C++` these days. Smart pointers and references are all I need."

"Oh, lifetimes? That... seems pretty cool actually. Having some kind of promise that a reference will live as long as I'm using it is quite nice actually. But.. smart pointers help with that!"

"Wait, everything gets moved? There is no copy? What madness is that? Oh efficiency and safety? Oh that's nice.""

"Optional results? We have that in `C++`. That's not what you mean? Well what do you mean?"

```rust
fn some_function_call() -> Result<i32, SomeError> {
	some_other_function_call("some parameter value")?
}
```

"Oh `Optional` and `Result` are error-encapsulating types. I see. That question mark syntax does really look handy. It'll remove a lot of `try ... catch` verbosity."

```rust
if let Ok(result) = some_function_call() {
	do_something_with(result);
}
```

"I missed that first time round - what on earth is that madness? You can't do that! Where's the parentheses around the condition? Ah hold on - did you just unpack that `Result` and check if `.ok()` in one line? Right, I'm sold."

"[There's more? Stop! I'm already convinced!](https://doc.rust-lang.org/rust-by-example/index.html)"

## And so began my journey into rust.
